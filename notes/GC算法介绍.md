### GC算法介绍

- GC可以找到内存中的垃圾、并释放和回收空间
- GC里的垃圾是什么？

	    //此处演示name变量在func()函数调用后，上下文里不再需要去用到name对象了
	    function func() {
	      name = 'lg'
	      return `${name} is a coder`
	    }
	    
	    func()
	    
	    //此处演示name变量添加了变量声明关键字，当函数调用结束后，我们在外部的空间中不能够再访问到它
	    function func() {
	      const name = 'lg'
	      return `${name} is a coder`
	    }
	    
	    func()

- GC算法是什么？

	* GC是一种机制，垃圾回收器完成具体的工作
	* 工作的内容就是查找垃圾释放空间、回收空间
	* 算法就是工作时查找和回收所遵循的规则 

- 常见的GC算法
	
	* 引用计数
	* 标记清除
	* 标记整理
	* 分代回收

### 引用计数算法

- 核心思想
	
	在内部通过引用计数器来维护当前对象的引用数，判断当前引用数是否为0，来判断当前对象是不是垃圾对象。

- 引用计数器导致了引用计数方法在执行效率上跟其他算法的一些区别

- 引用的数值什么时候改变？

	当某一个对象的引用关系发生改变的时候，引用计数器就会主动的去修改这个对象所对应的引用数值。

- 什么叫做引用关系发生改变？

	例如说，代码里有一个对象空间，有一个变量名指向它，那么这个时候引用计数+1，如果又多了一个对象指向它，那么引用计数再+1，那么，如果指向减少的时候-1，当引用数字为0的时候，GC就会立即工作，将当前的对象空间立即回收。

- 引用计数算法优点

	- 发现垃圾时立即回收
	- 最大限度减少程序暂停
		
		当发现内存空间不足时，立即找到引用计数值为0的对象，并进行释放，所以能够最大限度减少程序暂停

- 引用计数算法缺点

	- 无法回收循环引用的对象

			//此时obj1和obj2存在互相引用的情况，
			//虽然脚本运行完后，外部没有对obj1和obj2的引用，
			//但是此时的引用计数还是不会为0，因为存在循环引用的问题
			function fn() {
			    const obj1 = {}
			    const obj2 = {}
			
			    obj1.name = obj2
			    obj2.name = obj1
			
			    return 'lg is a coder'
			}
			fn()

	- 时间开销大

		由于每个使用引用计数算法的对象都需要时刻监控当前引用计数的变化，维持引用计数的修改，计数的修改也需要消耗时间，所以当内存里需要更多的对象需要修改，那么时间消耗会更大。

### 标记清除算法

- 实现原理

	核心思想：分为标记和清除两个阶段进行。第一次遍历所有对象，对全局可达对象进行标记操作，第二次遍历所有对象，将带有标记的对象的标记进行清除，有利于下次GC操作的时候正常工作，同时回收没有标记的对象所在的对象空间，并将其放入空闲链表中

- 标记清除算法优点

	- 能够解决引用计数算法在对象循环引用时不能进行回收操作的问题

- 标记清除算法缺点

	- 对于回收的空间来说，可能会导致地址的不连续性，也就是空间的碎片化。如果后续申请使用空间，那么不管空闲空间是多了还是少了，都不合适。不能让空间得到最大化的使用。
		
		![标记清除算法缺点](https://note.youdao.com/yws/public/resource/cf4c1c1f89527ccacdbaf2bb51c1a8fd/xmlnote/WEBRESOURCEa91ea575b3d489ebb16eef3850096b5e/1136)

### 标记整理算法

- 实现原理

	- 标记整理可以看作是标记清除算法的增强
	- 标记阶段的操作和标记清除一致。**即第一遍遍历所有的对象，并将全局可达对象进行标记处理**
	- 清除阶段会先执行整理，移动对象位置**对于标记清除来说，标记整理会在第二次遍历所有对象时先进行整理操作，然后再执行清除操作，这样的话就可以避免空间的碎片化问题**


### 标记增量算法

当垃圾回收进行工作的时候，程序执行是会被阻塞的。当需要GC操作的时候，需要程序停下来执行GC操作。

![](https://note.youdao.com/yws/public/resource/cf4c1c1f89527ccacdbaf2bb51c1a8fd/xmlnote/WEBRESOURCE2190a0ca1a2a860ce77c571e69421c21/1141)

- 实现原理

	- 简单的去说，就是将我们当前一整段垃圾回收操作拆分成多个小步，组合的去完成当前我们整个回收，从而去替代我们之前一口气完成的垃圾回收操作
	- 主要就是让我们可以实现垃圾回收与程序执行交替着执行。这样带来的时间消耗更加的合理一些。

标记增量执行过程，由上图可见：

- 程序开始执行的时候是不需要执行垃圾回收的
- 一旦触发了垃圾回收，（此处针对于老生代）这时都会进行遍历和标记的操作
- 在遍历的过程中，存在标记操作，这时的标记可以不用一次完成，因为活动对象存在直接可达和间接可达的区别
- 这样的话，第一步我们可以先找到第一层的可达对象，将其标记
- 然后停下来让程序执行一会，程序执行一会后
- 我们再让GC机制去做第二步操作，找到遍历子对象中的可达对象，将其标记
- 然后再让GC操作停下来，继续执行程序
- 如此交替进行这两件事，直到我们的标记操作完成以后，我们再进行垃圾回收
- 最终当我们完成了垃圾回收操作后，再让程序继续执行它该做的操作